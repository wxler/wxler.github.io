<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/assets/logo.png?v=2.0.0" type="image/png" sizes="16x16"><link rel="icon" href="/assets/logo.png?v=2.0.0" type="image/png" sizes="32x32"><meta name="description" content="一致性算法2PC、3PC、Paxos、Raft、ZAB">
<meta property="og:type" content="article">
<meta property="og:title" content="一致性算法2PC、3PC、Paxos、Raft、ZAB">
<meta property="og:url" content="https://wxler.github.io/2021/03/08/203219/index.html">
<meta property="og:site_name" content="Layne&#39;s Blog">
<meta property="og:description" content="一致性算法2PC、3PC、Paxos、Raft、ZAB">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/wxler/blogimg/raw/master/imgs/20210308210829.png">
<meta property="og:image" content="https://gitee.com/wxler/blogimg/raw/master/imgs/20210308212105.png">
<meta property="og:image" content="https://gitee.com/wxler/blogimg/raw/master/imgs/20210308220007.png">
<meta property="og:image" content="https://gitee.com/wxler/blogimg/raw/master/imgs/20210308224156.png">
<meta property="og:image" content="https://gitee.com/wxler/blogimg/raw/master/imgs/20210308224748.png">
<meta property="og:image" content="https://gitee.com/wxler/blogimg/raw/master/imgs/20210308225001.png">
<meta property="og:image" content="https://gitee.com/wxler/blogimg/raw/master/imgs/20210309095818.png">
<meta property="og:image" content="https://gitee.com/wxler/blogimg/raw/master/imgs/20210309094653.png">
<meta property="og:image" content="https://gitee.com/wxler/blogimg/raw/master/imgs/20210309100031.png">
<meta property="og:image" content="https://gitee.com/wxler/blogimg/raw/master/imgs/20210309101121.png">
<meta property="og:image" content="https://gitee.com/wxler/blogimg/raw/master/imgs/20210309101153.png">
<meta property="og:image" content="https://gitee.com/wxler/blogimg/raw/master/imgs/20210309101559.png">
<meta property="og:image" content="https://gitee.com/wxler/blogimg/raw/master/imgs/20210309202934.png">
<meta property="og:image" content="https://gitee.com/wxler/blogimg/raw/master/imgs/20210309204307.png">
<meta property="og:image" content="https://gitee.com/wxler/blogimg/raw/master/imgs/20210309205602.png">
<meta property="og:image" content="https://gitee.com/wxler/blogimg/raw/master/imgs/20210309214242.png">
<meta property="og:image" content="https://gitee.com/wxler/blogimg/raw/master/imgs/20210309215027.png">
<meta property="og:image" content="https://gitee.com/wxler/blogimg/raw/master/imgs/20210309215338.png">
<meta property="article:published_time" content="2021-03-08T12:32:19.000Z">
<meta property="article:modified_time" content="2021-03-14T08:17:16.564Z">
<meta property="article:author" content="wxler">
<meta property="article:tag" content="zookeeper">
<meta property="article:tag" content="ZAB">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/wxler/blogimg/raw/master/imgs/20210308210829.png"><meta name="keywords" content="wxler, Layne's Blog"><meta name="description" content="博客，分享，开源，心得"><title>一致性算法2PC、3PC、Paxos、Raft、ZAB | Layne's Blog</title><link ref="canonical" href="https://wxler.github.io/2021/03/08/203219/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.0.0"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?01911aa0fc6bdb840626994292397110';
  hm.async = true;

  if (true) {
    hm.setAttribute('data-pjax', '');
  }
  var s = document.getElementsByTagName('script')[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"ocean","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: true,
  pjax: {"avoidBanner":true},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/message/"><span class="header-nav-menu-item__icon"><i class="fa fa-comment"></i></span><span class="header-nav-menu-item__text">留言板</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Layne's Blog</div><div class="header-banner-info__subtitle">一个爱好coding的男孩纸</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">一致性算法2PC、3PC、Paxos、Raft、ZAB</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-03-08</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-03-14</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">8.4k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">45分</span></span></div></header><div class="post-body"><p><strong>一致性算法2PC、3PC、Paxos、Raft、ZAB</strong></p>
<a id="more"></a>
<p><strong>文章目录</strong></p>
<p><ul class="markdownIt-TOC">
<li><a href="#%E7%AE%80%E8%BF%B0">简述</a></li>
<li><a href="#%E4%B8%80-2pc%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4">一、2PC（两阶段提交）</a></li>
<li><a href="#%E4%BA%8C-3pc">二、3PC</a></li>
<li><a href="#%E4%B8%89-paxos-%E7%AE%97%E6%B3%95">三、Paxos 算法</a>
<ul>
<li><a href="#31-%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5prepare-%E9%98%B6%E6%AE%B5">3.1 第一阶段：prepare 阶段</a></li>
<li><a href="#32-%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5accept-%E9%98%B6%E6%AE%B5">3.2 第二阶段：accept 阶段</a></li>
<li><a href="#33-paxos-%E7%AE%97%E6%B3%95%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98">3.3 paxos 算法的死循环问题</a></li>
<li><a href="#34-%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E">3.4 举例说明</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-raft">四、Raft</a></li>
<li><a href="#%E4%BA%94-zab">五、ZAB</a>
<ul>
<li><a href="#51-zab-%E4%B8%AD%E7%9A%84%E4%B8%89%E4%B8%AA%E8%A7%92%E8%89%B2">5.1 ZAB 中的三个角色</a></li>
<li><a href="#52-zxid%E5%92%8Cmyid">5.2 ZXID和myid</a></li>
<li><a href="#53-%E5%8E%86%E5%8F%B2%E9%98%9F%E5%88%97">5.3 历史队列</a></li>
<li><a href="#54-%E6%B6%88%E6%81%AF%E5%B9%BF%E6%92%AD%E6%A8%A1%E5%BC%8F">5.4 消息广播模式</a></li>
<li><a href="#55-%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D%E6%A8%A1%E5%BC%8F">5.5 崩溃恢复模式</a></li>
<li><a href="#56-%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98">5.6 脑裂问题</a></li>
</ul>
</li>
</ul>
</p>

        <h2 id="简述"   >
          <a href="#简述" class="heading-link"><i class="fas fa-link"></i></a>简述</h2>
      
<p>一个分布式系统可能面临多个问题：</p>
<ol>
<li>消息传递异步无序: 现实网络不是一个可靠的信道，存在消息延时、丢失，节点间消息传递做不到同步有序</li>
<li>节点宕机: 节点持续宕机，不会恢复</li>
<li>节点宕机恢复: 节点宕机一段时间后恢复，在分布式系统中最常见</li>
<li>网络分化: 网络链路中的某个部位出现问题</li>
<li>拜占庭将军问题: 在消息丢失的不可靠信道上试图通过消息传递的方式达到一致性是不可能的，所以所有的一致性算法的 <strong>必要前提</strong> 就是安全可靠的消息通道，发出的信号不会被篡改。</li>
</ol>
<blockquote>
<p>拜占庭将军问题：是指 拜占庭帝国军队的将军们必须全体一致的决定是否攻击某一支敌军。问题是这些将军在地理上是分隔开来的，只能依靠通讯员进行传递命令，但是通讯员中存在叛徒，它们可以篡改消息，叛徒可以欺骗某些将军采取进攻行动；促成一个不是所有将军都同意的决定，如当将军们不希望进攻时促成进攻行动；或者迷惑某些将军，使他们无法做出决定。</p>
</blockquote>
<p>而为什么要去解决数据一致性的问题？你想想，如果将网上商城购物系统拆分成了订单和积分子系统，这两个子系统部署在不同的机器上了，万一在消息的传播过程中积分系统宕机了，总不能你这边下了订单却没加积分吧？你总得保证两边的数据需要一致吧？</p>

        <h2 id="一-2pc两阶段提交"   >
          <a href="#一-2pc两阶段提交" class="heading-link"><i class="fas fa-link"></i></a>一、2PC（两阶段提交）</h2>
      
<blockquote>
<p>千万不要吧PC理解成个人电脑了，其实他们是 phase-commit 的缩写，即阶段提交。</p>
</blockquote>
<p>2PC(tow phase commit)两阶段提交，所谓的两个阶段是指：第一阶段：<code>准备阶段</code>，第二阶段：<code>提交阶段</code>。</p>
<blockquote>
<p>在我们所需要解决的是在分布式系统中，<strong>整个调用链中</strong>，我们所有服务的数据处理要么都成功要么都失败，即所有服务的 <strong>原子性问题</strong> 。</p>
</blockquote>
<p>两阶段提交是一种保证分布式系统数据一致性协议，它本身是一致强一致性算法，现在很多<strong>数据库</strong>都是采用的两阶段提交协议来完成 <strong>分布式事务</strong> 的处理。</p>
<p>在两阶段提交中，主要涉及到两个角色，分别是协调者和参与者。</p>
<p>第一阶段：当要执行一个分布式事务的时候，事务发起者首先向协调者发起事务请求，然后协调者会给所有参与者发送 <code>prepare</code> 请求（其中包括事务内容）告诉参与者你们需要执行事务了，如果能执行我发的事务内容那么就先执行但不提交，执行后请给我回复。然后参与者收到 <code>prepare</code> 消息后，他们会开始执行事务（但不提交），并将 <code>Undo</code> 和 <code>Redo</code> 信息记入事务日志中，之后参与者就向协调者反馈是否准备好了。</p>
<p>第二阶段：第二阶段主要是协调者根据参与者反馈的情况来决定接下来是否可以进行事务的提交操作，即提交事务或者回滚事务。</p>
<p>比如这个时候 <strong>所有的参与者</strong> 都返回了准备好了的消息，这个时候就进行事务的提交，协调者此时会给所有的参与者发送 <strong><code>Commit</code> 请求</strong> ，当参与者收到 <code>Commit</code> 请求的时候会执行前面执行的事务的 <strong>提交操作</strong> ，提交完毕之后将给协调者发送提交成功的响应。</p>
<p>而如果在第一阶段并不是所有参与者都返回了准备好了的消息，那么此时协调者将会给所有参与者发送 <strong>回滚事务的 <code>rollback</code> 请求</strong>，参与者收到之后将会 <strong>回滚它在第一阶段所做的事务处理</strong> ，然后再将处理情况返回给协调者，最终协调者收到响应后便给事务发起者返回处理失败的结果。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/wxler/blogimg/raw/master/imgs/20210308210829.png"  alt="" />
      </p>
<p>优点：原理简单，实现方便</p>
<p>缺点：<code>单点问题</code>，<code>同步阻塞</code>，，<code>数据不一致</code>，<code>容错性不好</code></p>
<ul>
<li><strong>单点故障问题</strong>，如果协调者挂了那么整个系统都处于不可用的状态了。</li>
<li><strong>阻塞问题</strong>，在二阶段提交的过程中，整体链路所有的节点都在等待其他节点的响应，无法进行其他操作。这种同步阻塞极大的限制了分布式系统的性能。</li>
<li><strong>数据不一致问题</strong>，比如当第二阶段，协调者只发送了一部分的 <code>commit</code> 请求就挂了，那么也就意味着，收到消息的参与者会进行事务的提交，而后面没收到的则不会进行事务提交，那么这时候就会产生数据不一致性问题。</li>
<li><strong>容错性不好</strong>，二阶段提交协议没有设计较为完善的容错机制，任意一个节点是失败都会导致整个事务的失败。</li>
</ul>

        <h2 id="二-3pc"   >
          <a href="#二-3pc" class="heading-link"><i class="fas fa-link"></i></a>二、3PC</h2>
      
<p>三阶段提交（Three-phase commit），是二阶段提交（2PC）的改进版本。与两阶段提交不同的是，三阶段提交有两个改动点。</p>
<ol>
<li><code>引入超时机制</code>。同时在协调者和参与者中都引入超时机制。</li>
<li>在第一阶段和第二阶段中插入一个<code>准备阶段</code>，保证了在最后提交阶段之前各参与节点的状态是一致的。也就是说，除了引入超时机制之外，<strong>3PC把2PC的准备阶段再次一分为二</strong>，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。</li>
</ol>
<blockquote>
<p>3PC是弱一致性算法，因为它引入超时时间，系统中的所有数据副本经过一定时间后，最终才能能够达到一致的状态</p>
</blockquote>
<p>各个阶段的执行过程如下：</p>
<ol>
<li><strong>CanCommit阶段</strong>：协调者向所有参与者发送 <code>CanCommit</code> 请求，参与者收到请求后会根据自身情况查看是否能执行事务，如果可以则返回 YES 响应并进入预备状态，否则返回 NO 。</li>
<li><strong>PreCommit阶段</strong>：协调者根据参与者返回的响应来决定是否可以进行下面的 <code>PreCommit</code> 操作。如果上面参与者返回的都是 YES，那么协调者将向所有参与者发送 <code>PreCommit</code> 预提交请求，<strong>参与者收到预提交请求后，会进行事务的执行操作，并将 <code>Undo</code> 和 <code>Redo</code> 信息写入事务日志中</strong> ，最后如果参与者顺利执行了事务则给协调者返回成功的响应。如果在第一阶段协调者收到了 <strong>任何一个 NO</strong> 的信息，或者 <strong>在一定时间内</strong> 并没有收到全部的参与者的响应，那么就会中断事务，它会向所有参与者发送中断请求（abort），参与者收到中断请求之后会立即中断事务，或者在一定时间内没有收到协调者的请求，它也会中断事务。</li>
<li><strong>DoCommit阶段</strong>：这个阶段其实和 <code>2PC</code> 的第二阶段差不多，如果协调者收到了所有参与者在 <code>PreCommit</code> 阶段的 YES 响应，那么协调者将会给所有参与者发送 <code>DoCommit</code> 请求，<strong>参与者收到 <code>DoCommit</code> 请求后则会进行事务的提交工作</strong>，完成后则会给协调者返回响应，协调者收到所有参与者返回的事务提交成功的响应之后则完成事务。若协调者在 <code>PreCommit</code> 阶段 <strong>收到了任何一个 NO 或者在一定时间内没有收到所有参与者的响应</strong> ，那么就会进行中断请求的发送，参与者收到中断请求后则会 <strong>通过上面记录的回滚日志</strong> 来进行事务的回滚操作，并向协调者反馈回滚状况，协调者收到参与者返回的消息后，中断事务。</li>
</ol>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/wxler/blogimg/raw/master/imgs/20210308212105.png"  alt="" />
      </p>
<p>上图是 <code>3PC</code> 成功运行时的流程图，可以看到 <code>3PC</code> 在很多地方进行了超时中断的处理，比如协调者在指定时间内为收到全部的确认消息则进行事务中断的处理，这样能 <strong>减少同步阻塞的时间</strong> 。还有需要注意的是，<strong><code>3PC</code> 在 <code>DoCommit</code> 阶段参与者如未收到协调者发送的提交事务的请求，也会在一定时间内进行事务的提交</strong>。为什么这么做呢？是因为这个时候我们肯定<strong>保证了在第一阶段所有的协调者全部返回了可以执行事务的响应</strong>，这个时候我们有理由<strong>相信其他系统都能进行事务的执行和提交</strong>，所以<strong>不管</strong>协调者有没有发<code>DoCommit</code> 请求给参与者，进入第三阶段参与者都会进行事务的提交操作。</p>
<p>总之，<code>3PC</code> 通过一系列的超时机制很好的缓解了阻塞问题，但是最重要的一致性并没有得到根本的解决，比如由于网络原因，协调者发送的abort中断请求没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort请求并执行回滚的参与者之间存在数据不一致的情况。</p>
<p>所以，要解决一致性问题还需要靠 <code>Paxos</code> 算法</p>

        <h2 id="三-paxos-算法"   >
          <a href="#三-paxos-算法" class="heading-link"><i class="fas fa-link"></i></a>三、Paxos 算法</h2>
      
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/wxler/blogimg/raw/master/imgs/20210308220007.png"  alt="" />
      </p>
<p>该算法的提出者莱斯利·兰伯特在前面几篇论文中都不是以严谨的数学公式进行的。其实这个paxos算法也分成两阶段。</p>
<p><code>Paxos</code> 算法是基于<strong>消息传递且具有高度容错特性的一致性算法</strong>，是目前公认的解决分布式一致性问题最有效的算法之一，<strong>其解决的问题就是在分布式系统中如何就某个值（决议）达成一致</strong> 。这 个“值”可能是一个数据的某，也可能是一条LOG等；根据不同的应用环境这个“值”也不同。在 <code>Paxos</code> 中主要有三个角色，分别为 <code>Proposer提案者</code>、<code>Acceptor表决者</code>、<code>Learner学习者</code>。</p>

        <h3 id="31-第一阶段prepare-阶段"   >
          <a href="#31-第一阶段prepare-阶段" class="heading-link"><i class="fas fa-link"></i></a>3.1 第一阶段：prepare 阶段</h3>
      
<p><code>Proposer提案者</code>选择一个<strong>具有全局唯一性的、递增的提案编号N</strong>，即在整个集群中是唯一的编号 N，在<strong>第一阶段是只将编号为N的Prepare请求发送给所有的表决者</strong>。</p>
<p>如果一个<code>Acceptor表决者</code>收到一个编号为N的Prepare请求，如果N小于它已经响应过的提案编号，则拒绝或不响应。若N大于该Acceptor已经响应过的所有Prepare请求的编号（maxN），那么Acceptor会将<strong>以前接受过的最大编号</strong>的提案作为响应反馈给 <code>Proposer</code> ，<strong>同时该Acceptor承诺不再接受任何编号小于N的提案</strong>。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/wxler/blogimg/raw/master/imgs/20210308224156.png"  alt="" />
      </p>

        <h3 id="32-第二阶段accept-阶段"   >
          <a href="#32-第二阶段accept-阶段" class="heading-link"><i class="fas fa-link"></i></a>3.2 第二阶段：accept 阶段</h3>
      
<p>如果Proposer收到半数以上Acceptor对其发出的编号为N的Prepare请求的响应，那么此时 <code>Proposer</code> 会给所有的 <code>Acceptor</code> 发送真正的提案（你可以理解为第一阶段为试探），这个时候 <code>Proposer</code> 就会发送提案的内容和提案编号。</p>
<p>表决者收到提案请求后会比较本身已经接受过的最大提案编号和该提案编号，如果该提案编号 <strong>大于等于</strong> 已经接受过的最大提案编号，那么就 <code>accept</code> 该提案（此时执行提案内容但不提交），随后将情况返回给 <code>Proposer</code> 。如果不满足则不回应或者返回 NO 。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/wxler/blogimg/raw/master/imgs/20210308224748.png"  alt="" />
      </p>
<p>当 <code>Proposer</code> 收到超过半数的 <code>accept</code> ，那么它这个时候会向所有的 <code>acceptor</code> 发送提案的<strong>提交请求</strong>。需要注意的是，因为上述仅仅是超过半数的 <code>acceptor</code> 批准执行了该提案内容，其他没有批准的并没有执行该提案内容，所以这个时候需要<strong>向未批准的 <code>acceptor</code> 发送提案内容和提案编号并让它无条件执行和提交</strong>，而对于前面已经批准过该提案的 <code>acceptor</code> 来说 <strong>仅仅需要发送该提案的编号</strong> ，让 <code>acceptor</code> 执行提交就行了。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/wxler/blogimg/raw/master/imgs/20210308225001.png"  alt="" />
      </p>
<p>而如果 <code>Proposer</code> 如果没有收到超过半数的 <code>accept</code> 那么它将会将 <strong>递增</strong> 该 <code>Proposal</code> 的编号，然后 <strong>重新进入 <code>Prepare</code> 阶段</strong> 。</p>
<p>Learner学习被选定的第二阶段达成的某个值（决议），这里我们称之为Value。Learner学习方式有三种方案：</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/wxler/blogimg/raw/master/imgs/20210309095818.png"  alt="" />
      </p>

        <h3 id="33-paxos-算法的死循环问题"   >
          <a href="#33-paxos-算法的死循环问题" class="heading-link"><i class="fas fa-link"></i></a>3.3 paxos 算法的死循环问题</h3>
      
<blockquote>
<p>有的人说是活锁，我认为是死锁，因为比较两个proposer都没有完成Paxos的第二阶段，一直在重复自增提案编号，导致谁都无法最终完成提案，即造成两个进程争夺资源（这里提案编号资源），互相等待对方的资源，谁也不肯放弃，从而造成死锁。</p>
</blockquote>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/wxler/blogimg/raw/master/imgs/20210309094653.png"  alt="" />
      </p>
<p>选择一个主Proposer，并规定只有主Proposer才能提出议案。这样一来，只要主Proposer和过半的Acceptor能够正常进行网络通信，那么肯定会有一个提案被批准（第二阶段的accept），则可以解决死循环导致的活锁问题。</p>
<p>Paxos是基于消息传递的具有高度容错性的分布式一致性算法。<strong>Paxos算法引入了过半的概念，解决了2PC，3PC的太过保守的缺点，且使算法具有了很好的容错性</strong>，另外<strong>Paxos算法支持分布式节点角色之间的转换</strong>，这极大避免了分布式单点问题的出现，因此Paxos算法既解决了无限等待问题，也解决了脑裂问题，是目前来说最优秀的分布式一致性算法。其中，Zookeeper的ZAB算法和Raft一致性算法都是基于Paxos的。</p>

        <h3 id="34-举例说明"   >
          <a href="#34-举例说明" class="heading-link"><i class="fas fa-link"></i></a>3.4 举例说明</h3>
      
<p>假设：只有User1、User2、User3 三个人决定1+1等于几！</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/wxler/blogimg/raw/master/imgs/20210309100031.png"  alt="" />
      </p>
<p><strong>第一阶段</strong></p>
<ol>
<li>User1 提案编号为 1 并发送给User2和User3。</li>
</ol>
<p>因User2 和User3 并没有接受过小于编号为1的提案，所以它们可以接受该提议，并反馈给User1 不再接受小于编号1的提案。这时User1收到多数人的回复，将进入<strong>第2阶段</strong>。（如果收到的回复并不能形成多数人，那么将再次进入阶段1）</p>
<ol start="2">
<li>User2 提案编号为2 ，并发送给User1和User3。‘</li>
</ol>
<p>User1第一次收到提案，它并没有同意过小于编号为2的提议，所以它可以接受该提议。User3由于接受过User1编号为1的提案，但User2的提案编号 2 &gt; 1 所以User3也可以同意User2的提议，并反馈不再接受小于2的提议。User2也收到多数人的回复，将进行<strong>第2阶段</strong>。</p>
<ol start="3">
<li>User3提案编号为3 ，并发送给user1 和user2 .</li>
</ol>
<p>因user1收到user3编号为3的提案 &gt; user2编号为2的提案，所以接受user3的提案。因user2收到User3编号为3的提案 &gt; user1 编号为1的提案，所以接受user3的提案。至此user3也收到多数人回复，将进行第2阶段。</p>
<p><strong>第二阶段</strong></p>
<ol>
<li>user1 发送编号为1的提议，提议内容为：1+1=1；并发送给user2和User3 。</li>
</ol>
<p>由于user2已经声明不再接受小于3的提案，所以拒绝user1的提案。由于User3已经声明不再接受小于2的提案，所以同样拒绝User1的提案。User1提议被多数人拒绝，再次进入阶段1</p>
<ol start="2">
<li>user2 发送编号为2的提议，提议内容为：1+1=2；并发送给User1和User3</li>
</ol>
<p>由于User1已经声明不再接受小于3的提案，所以拒绝user2的提议。由于User3已经声明不再接受小于2的提案，该提案编号=2所以user3同意User2的提议。但User2并没有获得多数人的同意，所以<code>同样进行阶段1</code>.</p>
<ol start="3">
<li>User3 发送编号为3的提议，提议内容为：1+1=3；并发送给User1和User2;</li>
</ol>
<p>由于 user1 声明不再接受小于3的提案，所以同意User3的提议。由于 user2 声明不再接受小于3的提案，所以同意User3的提议。</p>
<p>至此最终User3可以获得多数人的同意。</p>
<p><strong>虽然上面没有说自己同意自己，但我认为自己可以同意自己，毕竟如果有三台机器，总不可能让另外两台都同意吧，这不就成了在投票阶段3台决定Leader了。</strong></p>

        <h2 id="四-raft"   >
          <a href="#四-raft" class="heading-link"><i class="fas fa-link"></i></a>四、Raft</h2>
      
<p>Raft 也是一个一致性算法，和 Paxos 目标相同。但他还有另一个名字：易于理解的一致性算法。也就是说，他的目标就是成为一个易于理解的一致性算法。以替代 Paxos 的晦涩难懂。</p>
<p><strong>什么是 Raft 算法</strong></p>
<p>首先说什么是 Raft 算法：<strong>Raft 是一种为了管理复制日志的一致性算法</strong>。</p>
<p>什么是一致性呢？</p>
<blockquote>
<p>Raft 的论文这么说的：<strong>一致性算法允许一组机器像一个整体一样工作，即使其中一些机器出现故障也能够继续工作下去</strong>。</p>
</blockquote>
<p>这里的一致性针对分布式系统。</p>
<p><strong>领导人选举</strong></p>
<p>Raft 通过选举一个高贵的领导人，然后给予他全部的管理复制日志的责任来实现一致性。</p>
<p>而每个 server 都可能会在 3 个身份之间切换：</p>
<blockquote>
<p>领导者 候选者 跟随者</p>
</blockquote>
<p>而影响他们身份变化的则是 选举。当所有服务器初始化的时候，都是 跟随者，这个时候需要一个 领导者，所有人都变成 候选者，直到有人成功当选 领导者。角色轮换如下图：</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/wxler/blogimg/raw/master/imgs/20210309101121.png"  alt="" />
      </p>
<p>而领导者也有宕机的时候，宕机后引发新的 选举，所以，整个集群在选举和正常运行之间切换，具体如下图：</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/wxler/blogimg/raw/master/imgs/20210309101153.png"  alt="" />
      </p>
<p>从上图可以看出，选举和正常运行之间切换，但请注意， 上图中的 term 3 有一个地方，后面没有跟着 正常运行 阶段，为什么呢?</p>
<p>答：当一次选举失败（比如正巧每个人都投了自己），就执行一次 <strong>加时赛</strong>，每个 Server 会在一个随机的时间里重新投票，这样就能保证不冲突了。所以，当 term 3 选举失败，等了几十毫秒，执行 term 4 选举，并成功选举出领导人。</p>
<p>接着，领导者<strong>周期性</strong>的向所有跟随者发送心跳包来维持自己的权威。如果一个跟随者在一段时间里没有接收到任何消息，也就是选举超时，那么他就会认为系统中没有可用的领导者,并且发起选举以选出新的领导者。</p>
<p>要开始一次选举过程，跟随者先要增加自己的当前任期号并且转换到候选人状态。然后请求其他服务器为自己投票。那么会产生 3 种结果：</p>
<p>a. 自己成功当选 b. 其他的服务器成为领导者 c. 僵住，没有任何一个人成为领导者</p>
<p>注意：</p>
<p>每一个 server 最多在一个任期内投出一张选票（有任期号约束），先到先得。要求最多只能有一个人赢得选票。一旦成功，立即成为领导人，然后广播所有服务器停止投票阻止新得领导产生。僵住怎么办？Raft 通过使用随机选举超时时间（例如 150 - 300 毫秒）的方法将服务器打散投票。每个候选人在僵住的时候会随机从一个时间开始重新选举。以上，就是 Raft 所有关于领导选举的策略。</p>
<p><strong>日志复制</strong></p>
<p>一旦一个领导人被选举出来，他就开始为客户端提供服务。客户端发送日志给领导者，随后领导者将日志复制到其他的服务器。如果跟随者故障，领导者将会尝试重试。直到所有的跟随者都成功存储了所有日志。</p>
<p>下图表示了当一个客户端发送一个日志给领导者，随后领导者复制给跟随者的整个过程</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/wxler/blogimg/raw/master/imgs/20210309101559.png"  alt="" />
      </p>
<p>4 个步骤：</p>
<ol>
<li>客户端提交</li>
<li>复制数据到所有跟随者</li>
<li>跟随者回复 确认收到</li>
<li>领导者回复客户端和所有跟随者 确认提交。</li>
</ol>
<p>可以看到，直到第四步骤，整个事务才会达成。中间任何一个步骤发生故障，都不会影响日志一致性。</p>
<p>Raft算法具备强一致、高可靠、高可用等优点，具体体现在：</p>
<p><code>强一致性</code>：虽然所有节点的数据并非实时一致，但Raft算法保证Leader节点的数据最全，同时所有请求都由Leader处理，所以在客户端角度看是强一致性的。</p>
<p><code>高可靠性</code>：Raft算法保证了Committed的日志不会被修改，State Matchine只应用Committed的日志，所以当客户端收到请求成功即代表数据不再改变。Committed日志在大多数节点上冗余存储，少于一半的磁盘故障数据不会丢失。</p>
<p><code>高可用性</code>：从Raft算法原理可以看出，选举和日志同步都只需要大多数的节点正常互联即可，所以少量节点故障或网络异常不会影响系统的可用性。即使Leader故障，在选举超时到期后，集群自发选举新Leader，无需人工干预，不可用时间极小。但Leader故障时存在重复数据问题，需要业务去重或幂等性保证。</p>
<p><code>高性能</code>：与必须将数据写到所有节点才能返回客户端成功的算法相比，Raft算法只需要大多数节点成功即可，少量节点处理缓慢不会延缓整体系统运行。</p>

        <h2 id="五-zab"   >
          <a href="#五-zab" class="heading-link"><i class="fas fa-link"></i></a>五、ZAB</h2>
      
<p>作为一个优秀高效且可靠的分布式协调框架，<code>ZooKeeper</code> 在解决分布式数据一致性问题时并没有直接使用 <code>Paxos</code> ，而是专门定制了一致性协议叫做 <code>ZAB(ZooKeeper Automic Broadcast)</code> 原子广播协议，该协议能够很好地支持 <strong>崩溃恢复</strong> 。</p>

        <h3 id="51-zab-中的三个角色"   >
          <a href="#51-zab-中的三个角色" class="heading-link"><i class="fas fa-link"></i></a>5.1 ZAB 中的三个角色</h3>
      
<p>ZAB 中三个主要的角色，Leader 领导者、Follower跟随者、Observer观察者 。</p>
<ul>
<li><code>Leader</code> ：集群中 <strong>唯一的写请求处理者</strong> ，能够发起投票（投票也是为了进行写请求）。</li>
<li><code>Follower</code>：能够接收客户端的请求，如果是读请求则可以自己处理，<strong>如果是写请求则要转发给 <code>Leader</code></strong> 。在选举过程中会参与投票，<strong>有选举权和被选举权</strong> 。</li>
<li><code>Observer</code> ：就是没有选举权和被选举权的 <code>Follower</code> 。</li>
</ul>
<p>在 <code>ZAB</code> 协议中对 <code>zkServer</code>(即上面我们说的三个角色的总称) 还有两种模式的定义，分别是 <strong>消息广播</strong> 和 <strong>崩溃恢复</strong> 。</p>

        <h3 id="52-zxid和myid"   >
          <a href="#52-zxid和myid" class="heading-link"><i class="fas fa-link"></i></a>5.2 ZXID和myid</h3>
      
<p><strong>ZooKeeper</strong> 采用全局递增的事务 id 来标识，所有 proposal(提议)在被提出的时候加上了<strong>ZooKeeper Transaction Id</strong> 。ZXID是64位的Long类型，<strong>这是保证事务的顺序一致性的关键</strong>。ZXID中高32位表示纪元<strong>epoch</strong>，低32位表示事务标识<strong>xid</strong>。你可以认为zxid越大说明存储数据越新，如下图所示：</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/wxler/blogimg/raw/master/imgs/20210309202934.png"  alt="" />
      </p>
<ol>
<li>每个leader都会具有不同的<strong>epoch</strong>值，表示一个纪元/朝代，用来标识 leader周期。每个新的选举开启时都会生成一个新的epoch，从1开始，每次选出新的Leader，epoch递增1，并会将该值更新到所有的zkServer的zxid的epoch。</li>
<li><strong>xid</strong>是一个依次递增的事务编号。数值越大说明数据越新，可以简单理解为递增的事务id。<strong>每次epoch变化，都将低32位的序号重置</strong>，这样保证了zxid的全局递增性。</li>
</ol>
<p>每个ZooKeeper服务器，都需要在数据文件夹下创建一个名为myid的文件，该文件包含整个ZooKeeper集群唯一的id（整数）。例如，某ZooKeeper集群包含三台服务器，hostname分别为zoo1、zoo2和zoo3，其myid分别为1、2和3，则在配置文件中其id与hostname必须一一对应，如下所示。在该配置文件中，<code>server.</code>后面的数据即为myid</p>
<figure class="highlight tex"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.1=zoo1:2888:3888</span><br><span class="line">server.2=zoo2:2888:3888</span><br><span class="line">server.3=zoo3:2888:3888</span><br></pre></td></tr></table></div></figure>

        <h3 id="53-历史队列"   >
          <a href="#53-历史队列" class="heading-link"><i class="fas fa-link"></i></a>5.3 历史队列</h3>
      
<p>每一个follower节点都会有一个<strong>先进先出</strong>（FIFO)的队列用来存放收到的事务请求，保证执行事务的顺序。所以：</p>
<ul>
<li>可靠提交由ZAB的事务一致性协议保证</li>
<li>全局有序由TCP协议保证</li>
<li>因果有序由follower的历史队列(history queue)保证</li>
</ul>

        <h3 id="54-消息广播模式"   >
          <a href="#54-消息广播模式" class="heading-link"><i class="fas fa-link"></i></a>5.4 消息广播模式</h3>
      
<p>ZAB协议两种模式：消息广播模式和崩溃恢复模式。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/wxler/blogimg/raw/master/imgs/20210309204307.png"  alt="" />
      </p>
<p>说白了就是 <code>ZAB</code> 协议是如何处理写请求的，上面我们不是说只有 <code>Leader</code> 能处理写请求嘛？那么我们的 <code>Follower</code> 和 <code>Observer</code> 是不是也需要 <strong>同步更新数据</strong> 呢？总不能数据只在 <code>Leader</code> 中更新了，其他角色都没有得到更新吧。</p>
<p>第一步肯定需要 <code>Leader</code> 将写请求 <strong>广播</strong> 出去呀，让 <code>Leader</code> 问问 <code>Followers</code> 是否同意更新，如果超过半数以上的同意那么就进行 <code>Follower</code> 和 <code>Observer</code> 的更新（和 <code>Paxos</code> 一样）。消息广播机制是通过如下图流程<strong>保证事务的顺序一致性</strong>的：</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/wxler/blogimg/raw/master/imgs/20210309205602.png"  alt="" />
      </p>
<ol>
<li>leader从客户端收到一个写请求</li>
<li>leader生成一个新的事务并为这个事务生成一个唯一的ZXID</li>
<li>leader将这个事务发送给所有的follows节点，将带有 zxid 的消息作为一个提案(proposal)分发给所有 follower。</li>
<li>follower节点将收到的事务请求加入到历史队列(history queue)中，当 follower 接收到 proposal，先将 proposal 写到硬盘，写硬盘成功后再向 leader 回一个 ACK</li>
<li>当leader收到大多数follower（超过一半）的ack消息，leader会向follower发送commit请求（leader自身也要提交这个事务）</li>
<li>当follower收到commit请求时，会判断该事务的ZXID是不是比历史队列中的任何事务的ZXID都小，如果是则提交事务，如果不是则等待比它更小的事务的commit(保证顺序性)</li>
<li>Leader将处理结果返回给客户端</li>
</ol>
<p><strong>过半写成功策略</strong>：Leader节点接收到写请求后，这个Leader会将写请求广播给各个Server，各个Server会将该写请求加入历史队列，并向Leader发送ACK信息，当Leader收到一半以上的ACK消息后，说明该写操作可以执行。Leader会向各个server发送commit消息，各个server收到消息后执行commit操作。</p>
<p>这里要注意以下几点：</p>
<ul>
<li>Leader并不需要得到Observer的ACK，即Observer无投票权</li>
<li>Leader不需要得到所有Follower的ACK，只要收到过半的ACK即可，<strong>同时Leader本身对自己有一个ACK</strong></li>
<li>Observer虽然无投票权，但仍须同步Leader的数据从而在处理读请求时可以返回尽可能新的数据</li>
</ul>
<p>另外，Follower/Observer也可以接受写请求，此时：</p>
<ul>
<li>Follower/Observer接受写请求以后，不能直接处理，而需要将写请求转发给Leader处理</li>
<li>除了多了一步请求转发，其它流程与直接写Leader无任何区别</li>
<li>Leader处理写请求是通过上面的消息广播模式，实质上最后所有的zkServer都要执行写操作，这样数据才会一致</li>
</ul>
<p>而对于读请求，Leader/Follower/Observer都可直接处理读请求，从本地内存中读取数据并返回给客户端即可。由于处理读请求不需要各个服务器之间的交互，因此Follower/Observer越多，整体可处理的读请求量越大，也即读性能越好。</p>

        <h3 id="55-崩溃恢复模式"   >
          <a href="#55-崩溃恢复模式" class="heading-link"><i class="fas fa-link"></i></a>5.5 崩溃恢复模式</h3>
      
<p>恢复模式大致可以分为四个阶段：选举、发现、同步、广播。</p>
<ol>
<li><strong>选举阶段</strong>（Leader election）：当leader崩溃后，集群进入选举阶段（下面会将如何选举Leader），开始选举出潜在的准 leader，然后进入下一个阶段。</li>
<li><strong>发现阶段</strong>（Discovery）：用于在从节点中发现最新的ZXID和事务日志。准Leader接收所有Follower发来各自的最新epoch值。Leader从中选出最大的epoch，基于此值加1，生成新的epoch分发给各个Follower。各个Follower收到全新的epoch后，返回ACK给Leader，带上各自最大的ZXID和历史提议日志。Leader选出最大的ZXID，并更新自身历史日志，此时Leader就用拥有了最新的提议历史。（注意：每次epoch变化时，ZXID的第32位从0开始计数）。</li>
<li><strong>同步阶段</strong>（Synchronization）：主要是利用 leader 前一阶段获得的最新提议历史，同步给集群中所有的Follower。只有当超过半数Follower同步成功，这个准Leader才能成为正式的Leader。这之后，follower 只会接收 zxid 比自己的 lastZxid 大的提议。</li>
<li>广播阶段（Broadcast）：集群恢复到广播模式，开始接受客户端的写请求。</li>
</ol>
<blockquote>
<p>在发现阶段，或许有人会问：既然Leader被选为主节点，已经是集群里数据最新的了，为什么还要从节点中寻找最新事务呢？这是为了防止某些意外情况。所以这一阶段，Leader集思广益，接收所有Follower发来各自的最新epoch值。</p>
</blockquote>
<p>这里有两点要注意：</p>
<p>（1）<strong>确保已经被Leader提交的提案最终能够被所有的Follower提交</strong></p>
<p>假设 <code>Leader (server2)</code> 发送 <code>commit</code> 请求（忘了请看上面的消息广播模式），他发送给了 <code>server3</code>，然后要发给 <code>server1</code> 的时候突然挂了。这个时候重新选举的时候我们如果把 <code>server1</code> 作为 <code>Leader</code> 的话，那么肯定会产生数据不一致性，因为 <code>server3</code> 肯定会提交刚刚 <code>server2</code> 发送的 <code>commit</code> 请求的提案，而 <code>server1</code> 根本没收到所以会丢弃。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/wxler/blogimg/raw/master/imgs/20210309214242.png"  alt="" />
      </p>
<p>那怎么解决呢？</p>
<p><strong>这个时候 <code>server1</code> 已经不可能成为 <code>Leader</code> 了，因为 <code>server1</code> 和 <code>server3</code> 进行投票选举的时候会比较 <code>ZXID</code> ，而此时 <code>server3</code> 的 <code>ZXID</code> 肯定比 <code>server1</code> 的大了</strong>（后面讲到选举机制时就明白了）。同理，只能由server3当Leader，server3当上Leader之后，在同步阶段，会将最新提议历史同步给集群中所有的Follower，这就保证数据一致性了。如果server2在某个时刻又重新恢复了，它作为<code>Follower</code> 的身份进入集群中，再向Leader同步当前最新提议和Zxid即可。</p>
<p>（2）<strong>确保跳过那些已经被丢弃的提案</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/wxler/blogimg/raw/master/imgs/20210309215027.png"  alt="" />
      </p>
<p>假设 <code>Leader (server2)</code> 此时同意了提案N1，自身提交了这个事务并且要发送给所有 <code>Follower</code> 要 <code>commit</code> 的请求，却在这个时候挂了，此时肯定要重新进行 <code>Leader</code> 的选举，假如此时选 <code>server1</code> 为 <code>Leader</code> （这无所谓，server1和server2都可以当选）。但是过了一会，这个 <strong>挂掉的 <code>Leader</code> 又重新恢复了</strong> ，此时它肯定会作为 <code>Follower</code> 的身份进入集群中，需要注意的是刚刚 <code>server2</code> 已经同意提交了提案N1，但其他 <code>server</code> 并没有收到它的 <code>commit</code> 信息，所以其他 <code>server</code> 不可能再提交这个提案N1了，这样就会出现数据不一致性问题了，所以 <strong>该提案N1最终需要被抛弃掉</strong> 。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/wxler/blogimg/raw/master/imgs/20210309215338.png"  alt="" />
      </p>

        <h3 id="56-脑裂问题"   >
          <a href="#56-脑裂问题" class="heading-link"><i class="fas fa-link"></i></a>5.6 脑裂问题</h3>
      
<p>脑裂问题：所谓的“脑裂”即“大脑分裂”，也就是本来一个“大脑”被拆分了两个或多个“大脑”。通俗的说，就是比如当你的 cluster 里面有两个节点，它们都知道在这个 cluster 里需要选举出一个 master。那么当它们两之间的通信完全没有问题的时候，就会达成共识，选出其中一个作为 master。但是如果它们之间的通信出了问题，那么两个结点都会觉得现在没有 master，所以每个都把自己选举成 master，于是 cluster 里面就会有两个 master。</p>
<p>ZAB为解决脑裂问题，要求集群内的节点数量为2N+1, 当网络分裂后，始终有一个集群的节点数量过半数，而另一个集群节点数量小于N+1（即小于半数）, 因为选主需要过半数节点同意，所以任何情况下集群中都不可能出现大于一个leader的情况。</p>
<p>因此，有了过半机制，对于一个Zookeeper集群，要么没有Leader，要没只有1个Leader，这样就避免了脑裂问题。</p>
<p>【参考资料】</p>
<ol>
<li><span class="exturl"><a class="exturl__link"   href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/distributed-system/zookeeper/zookeeper-plus"  target="_blank" rel="noopener">https://snailclimb.gitee.io/javaguide/#/docs/system-design/distributed-system/zookeeper/zookeeper-plus</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link"   href="https://mp.weixin.qq.com/s/b5mGEbn-FLb9vhOh1OpwIg"  target="_blank" rel="noopener">https://mp.weixin.qq.com/s/b5mGEbn-FLb9vhOh1OpwIg</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ol>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://wxler.github.io">wxler</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://wxler.github.io/2021/03/08/203219/">https://wxler.github.io/2021/03/08/203219/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://wxler.github.io/tags/zookeeper/">zookeeper</a></span><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://wxler.github.io/tags/ZAB/">ZAB</a></span></div><div class="post-share"><div class="social-share" data-sites="qzone, qq, weibo, wechat, douban, linkedin, facebook, twitter, google">分享到：</div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2021/03/16/191640/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">hadoop伪分布式集群搭建</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2021/03/06/201454/"><span class="paginator-prev__text">Java的System.out.println有多慢，你知道吗？</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="valine-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简述"><span class="toc-text">
          简述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一-2pc两阶段提交"><span class="toc-text">
          一、2PC（两阶段提交）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二-3pc"><span class="toc-text">
          二、3PC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三-paxos-算法"><span class="toc-text">
          三、Paxos 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#31-第一阶段prepare-阶段"><span class="toc-text">
          3.1 第一阶段：prepare 阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-第二阶段accept-阶段"><span class="toc-text">
          3.2 第二阶段：accept 阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-paxos-算法的死循环问题"><span class="toc-text">
          3.3 paxos 算法的死循环问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-举例说明"><span class="toc-text">
          3.4 举例说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四-raft"><span class="toc-text">
          四、Raft</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五-zab"><span class="toc-text">
          五、ZAB</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#51-zab-中的三个角色"><span class="toc-text">
          5.1 ZAB 中的三个角色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52-zxid和myid"><span class="toc-text">
          5.2 ZXID和myid</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-历史队列"><span class="toc-text">
          5.3 历史队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54-消息广播模式"><span class="toc-text">
          5.4 消息广播模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55-崩溃恢复模式"><span class="toc-text">
          5.5 崩溃恢复模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56-脑裂问题"><span class="toc-text">
          5.6 脑裂问题</span></a></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/assets/myhexo.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">Practical And Realistic</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/wxler" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="mailto:wangxiaolei1516@qq.com" target="_blank" rel="noopener" data-popover="邮箱" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fa fa-envelope"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">113</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">20</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">54</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020~2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>wxler. All Rights Reserved.</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v4.2.1</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.0.0</span></div><div>托管于 <a href="https://github.com/wxler/" rel="noopener" target="_blank">Github</a></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (false) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" rel="stylesheet" type="text/css"><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.css" rel="stylesheet" type="text/css"><script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.min.js"></script></div><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script data-pjax="">function loadValine () {
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail';

  guest_info = guest_info.split(',').filter(function(item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  new Valine({
    el: '#valine-container',
    appId: 'kBUfBo302Sl5ViCNcWef6wYT-gzGzoHsz',
    appKey: 'hq4rU6YND5ziczBa2PLLUBiM',
    notify: true,
    verify: false,
    placeholder: '有什么需要和我说的，请填写昵称与邮箱(邮箱不会公开显示)，点击评论吧(支持匿名评论)！',
    avatar: 'mp',
    meta: guest_info,
    pageSize: '15' || 10,
    visitor: false,
    recordIP: false,
    lang: '' || 'zh-cn',
    path: window.location.pathname
  });
}

if (true) {
  loadValine();
} else {
  window.addEventListener('DOMContentLoaded', loadValine, false);
}</script><script src="/js/utils.js?v=2.0.0"></script><script src="/js/stun-boot.js?v=2.0.0"></script><script src="/js/scroll.js?v=2.0.0"></script><script src="/js/header.js?v=2.0.0"></script><script src="/js/sidebar.js?v=2.0.0"></script></body></html>